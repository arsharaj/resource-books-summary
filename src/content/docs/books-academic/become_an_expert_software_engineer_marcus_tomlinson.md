---
title: Become An Expert Software Engineer
description: A guide to the secret art of free and open source software development
---

> Marcus Tomlinson

### Chapter 1 : Reprogramming yourself for success

**Step 1 - Be proud to be an engineer**

* As a software engineer, your impact on the world is more significant than you might think.
* This book is aimed at anyone with an interest in writing software.
* Without interest in what you do, you will not have the motivation required to succeed.
* Choose a job you love, and you will want to work everyday of your life.

**Step 2 - Prepare to work for what you want**

* The only valueable form of experience is the kind you've worked for and can demonstrate.
* This is not a get rich quick scheme, working smart doesn't necessarily replace working hard.
* If your job does not leave you proud after a hard day's work, you need to find one that does.

**Step 3 - Take the dream out of dream job**

* Many of us direct frustration towards our field of work, rather than the job that drove us there.
* Aim high, reach for your dream job, and believe in yourself.
* Get the work experience you need by programming in your space time.
* Find a job that will be a perfect fit for you, then work on making yourself perfectly fit for it.

**Step 4 - Put your software where your mouth is**

* Your resume should contain hard evidence that proves you meet a job's requirements.
* Prove your proficiency in a skill by writing free and open source software to demonstrate it.
* Don't let money enter into the motivation you have for your dream job.
* Show your appreciation to open source by contributing well-written, helpful software.

**Step 5 - Understand what it takes to be an expert**

* Expertise is more often than not measured in the time you've spent deliberately practicing.
* It takes around 20 hours of deliberate practice to learn almost anything.
* It takes around 10,000 hours of deliberate practice to become an expert in almost anything.

### Chapter 2 : Choosing which technologies and domains to focus on

**Step 1 - Visualise yourself in your dream job**

* You should be putting time into practicing the specific set of skills required for your dream job.
* Every piece of code you add to your resume should be an investmest into your future.
* Visualise your dream job and write down as many key characteristics you envision it to have.

**Step 2 - Look for companies that interest you**

* Decide on which problem domain to focus on.
* Use LinkedIn.com to find the kinds of companies you're interested in.
* If enough companies within a particular problem domain don't interest you, pick another.
* Add any interesting technologies and subdomains you encounter to your list from step 1.

**Step 3 - Look for jobs that interest you**

* Decide on which technologies and subdomains to focus on.
* Use job search engines to find the kinds of jobs you're interested in.
* If enough jobs within a particular problem domain don't interest you, pick another.
* Add any interesting technologies and subdomains you encounter to your list from step 2.

**Step 4 - Define a specific career goal**

* Jobs for a particular specialisation are, for the most part, cut from the same mould.
* Mark duplicate entries on your list with an asterisk as these will almost certainly be required.
* Most technologies and subdomains that appear only once can be filtered out.

**Step 5 - Get your priorities straight**

* Assign each item on your list an interest level rating out of 10.
* Add to each item a rating out of 5 on how much previous experience you've had with it.
* Split asterisked and non-asterisked items, then rearrange each set according to total score.
* Recombine the list with asterisked items at the top and non-asterisked items at tht bottom.

### Chapter 3 : Coming up with a good project idea

**Step 1 - Pick a concentrated subject matter**

* Projects fail when they do not deliver on what they promise.
* Rather do simple well, than complex badly.
* Try to concentrate on showcasing just the top item on your list from the previous chapter.

**Step 2 - Look for problems that need solving**

* Software is created to solve problems, hence problems are a great source of inspiration.
* Regardless of what you're making, at least some of your time will be spent developing its API.
* Use stackoverflow.com to find common issues associated with your subject matter.

**Step 3 - Look for gaps that need filling**

* Learning from those who came before you is another great source of inspiration.
* Your aim should be to bring something new to the table.
* Use sourceforge.net to find popular projects associated with your subject matter.
* Note down any aspects that people particularly like or dislike about them from the reviews.

**Step 4 - Decide whether to create or contribute**

* A major advantage to creating is the educational benefit of developing a solution end-to-end.
* A major advantage to contributing is that it can add value to the company you're applying to.
* I lean towards creating as its advantages are greater, and its disadvantages can be avoided.
* All you need to create good software is a personal interest in seeing the problem solved.

**Step 5 - Establish a clear objective**

* Gather your notes from this chapter and identify common themes or directions.
* Come up with some one-liner descriptions of a few project ideas from the above themes.
* Pick the one that you feel you'd hove the most fun with, and ignore the rest for now.

### Chapter 4 : Designing your product

**Step 1 - Come up with a good name**

* It's more motivating to work on something that feels real, than to invest in the imaginary.
* Your project's title should convey an idea of what it does, and should be easy to remember.
* Use sourceforge.net to find similar projects, then brainstorm how yours could stand out.
* Put together a cover image that is simple and will subtly convey a sense of professionalism.

**Step 2 - Write up a project summary**

* Your product summary should be descriptive, unique, discoverable, and marketable.
* Use adwords.google.com to identify popular keywords for use in your summary.
* Formulate an elevator pitch for your project that is both brief and detailed at the same time.

**Step 3 - Create a product wish list**

* Use the problems and gaps that wound up under your project idea to form a product wish list.
* Write each high-level feature as if you were an end-user requesting it from the developer.
* Also assemble a "not" list containing features that do not fall within the scope of the project.

**Step 4 - Add research to your design**

* You should aim for just enough research to enable you to create smart, simple solutions.
* You have to grasp the "what" completely before you can determine the "how" and "why".
* Assign each item in your product wish list a research requirement rating out of 5.

**Step 5 - Plan a viable release schedule**

* The only variable force in software development is scope.
* Adjusting scope between releases allows you to deliver software on time, and on budget.
* A deadline is really the time in which you have to get as many features done as possible.
* Arrange your wish list in order of importance from highest to lowest.
* As you complete each feature, you should be able to release a new, fully-functional version.

### Chapter 5 : Setting up an open source project

**Step 1 - Pick an open source license**

* With free software, the definition of "free" depends on the license used.
* Understanding licenses is useful in licensing your own projects, as well as integrating others.
* Credit to the original author is honoured by complying with the appropriate license terms.
* Protection of trademark is honoured in much the same way that credit to the original author is.
* A license may or may not be compatible with other free or proprietary licenses.
* Protection against patent law grants all users free licenses to any patents used legally in the project.
* Stick with the Apache, BSD, MIT and LGPL (when it makes sense in a library) licenses.
* For more information on these licenses and their variations, see : opensource.org/licenses.

**Step 2 - Pick a version control system**

* You will not be taken seriously if your project's source is not managed by version control.
* A detailed project development history is almost mandatory in producing successful software.
* Choose a VCS that is popular to portray a sense of professionalism and familiarity to others.
* See the wikipedia article : Comparison of source code hosting facilities for popular VCS's.

**Step 3 - Pick a canned hosting site**

* Avoid the headache of constructing a complex project website by using canned hosting.
* See the wikipedia article : Comparison of source code hosting facilities for popular hosting sites.
* You could even create multiple pages for your project across more than one hosting site.

**Step 4 - Pick a web hosting site**

* Your project will be taken more seriously if it has its own dedicated website as well.
* Registering a domain name is optional, but you will at least need to register a web hosting plan.
* Use a document generator to create API documentation for your website.
* See the wikipedia article : Comparison of documentation generators.
* Writing documentation alongside your code means that it too will be stored in VCS.

**Step 5 - Create and configure your project**

* The act of creating a project page signifies that project's inception.
* Browse to your chosen canned hosting site, sign up and create a new project.
* Enable the bug tracker and add your wish list items to it.
* Enable the VCS and initialize a new "trunk" or "master" branch.

### Chapter 6 : Managing a part time work schedule

**Step 1 - Divide and conquer**

* Focus your energy on solving just the top item of your release schedule from chapter 4.
* The problems we face are naturally complex i.e. can be broken down into smaller tasks.
* First and foremost, you should create a task for research.
* As long as your current task is well defined, the rest can be reevaluated as you go.
* Start with a generic list of tasks such as : define api, write tests and implement back end.

**Step 2 - Practice time management**

* Good time management is a fundamental skill that every engineer should possess.
* It is far too easy to procrastinate without a manager, or a team depending on you.
* In software development, work is quantified in terms of complexity.
* The complexity of a problem is directly proportional to the time required to solve it.
* Calculate your work rate by assigning a complexity rating of 1, 2, 3, 5, or 8 to each task.

**Step 3 - Avoid distractions**

* While procrastinating can delay your software, distractions can kill it.
* There are two major forms of distraction you should avoid : physical and digital.
* If by solving one problem you uncover another, postpone it to a seperate task for later.
* Avoid premature optimisation.

**Step 4 - Don't rush**

* Rushing a task to completion is just as harmful as taking too long to complete it.
* Put your hobbies on hold, work whenever you can and avoid taking breaks longer than a week.
* Try to plan a work schedule that exceeds 20 hours.

**Step 5 - Enjoy yourself**

* "Professional" development does not necessarily have to mean "boring" development.
* At the very least, just try to make your code as readable as possible.
* Have fun, be easy on yourself, and be easy on your code.

### Chapter 7 : Writing good software

**Step 1 - Speak your project's language**

* Investigating into your chosen programming language should naturally form part of research.
* In software engineering, theory can not be fully appreciated until it is practiced.
* I'd recommend that you start with a good book or two on the subject.
* For free and non-free books see : github.com/vhj/free-programming-books and amazon.com.

**Step 2 - Lay a solid foundation**

* Start with a minimum project structure that "builds" with one, easy-to-perform action.
* Add automatic code validation as part of your project's "build".
* Branch from truck for each version such that all changes can be traced back to a release.
* When it comes to using version control : commit everything and commit often.

**Step 3 - Design a user friendly interface**

* Any good UI design begins with the design of a good API.
* Prefer simple over complex, use standard types and avoid long parameter lists.
* Every entity in your API should have only one well-defined, cohesive responsibility.
* Your API should exist to help its users, not to dump complex responsibilities onto them.
* Strongly coupled code is very difficult to maintain, and near impossible to reuse.
* Prefer dependency injection over inheritance, with the exception of abstract interfaces.
* Add document generator placeholders to each new entity you define.

**Step 4 - Put your interface to the test**

* Write a set of applications that, when run, will execute a sequence of tests against your API.
* New tests verify that new code works, and existing tests ensure that existing code still works.
* There are two main types of testing : unit (white box) and integration (black box).
* When fixing a bug in your code, the first thing you should do is write a "regression test".
* Your error conditions should be tested as thoroughly as your non-error conditions.
* Incorporate running tests as part of your project's build.

**Step 5 - Implement to the interface design**

* Prefer simple over complex, correct over fast, and safe over insecure.
* Establish a rational error handling policy for your project, and stick to it consistently.
* Avoid sharing global data between entities.
* Update your API documentation by filling in the placeholders you added in step 3.

### Chapter 8 : Releasing your project

**Step 1 - Pick a version numbering scheme**

* Pick a numbering scheme up front then version your software in relation to the state of its API.
* The most common versioning scheme is the three-component system. E.g. "2.4.0"
* Sometimes development status can be useful as a postfix to your version. E.g. "2.4.0-alpha"
* There are two directions to software compatibility : forward and backward.
* There are three major types of software compatibility : binary, source and functional.

**Step 2 - Clean up your project structure**

* Isolate a snapshot of your project into a staging branch and start cleaning up its file structure.
* A messy file structure strongly implies that the contents of those files are messy as well.
* Follow conventions used in other popular open source projects by browsing github.com.
* Create files for : "changes", "license", "install" and "readme".

**Step 3 - Update internal documentation**

* Building and utilising your code should be made as clear and straightforward as possible.
* "Install" should contain simple guidelines on how to build and install your software.
* "Readme" should contain the version, a brief description and links to other resources.
* "License" should contain the full license text for your project's license.
* "Changes" should contain high-level release notes in reverse chronological order.

**Step 4 - Update external documentation**

* External documentation should be designed such that it alone can make a good impression.
* First impressions last, so don't cut corners on your project's outward appearance.
* Use your documentation generator to create a home page for your website.
* If your software is an application, create seperate home pages for developers and end-users.
* Keep your canned hosting project page updated.

**Step 5 - Package and release**

* Provide an easy way to download your souce code as an archive.
* If your software results in an application or binary, provide seperate archives per platform.
* Stabilise your release, merge it to truck, re-sync development branches, then package.
* Upload your archives to the "Downloads" section of your canned hosting page.

### Chapter 9 : Marketing and maintaining your software

**Step 1 - Raise awareness of your project**

* The earlier you can get people using your software, the earlier you will get feedback.
* Ask friends and colleagues to be early adopters to your software.
* Find one or two of the above to give you a more in-depth review of the code as well.
* Extend an invitation to your reviewers to contribute to the project.
* Announce each noteworthy release at the top of your project page or website.

**Step 2 - Market yourself**

* Bare in mind that you are being watched almost as much as your work.
* Open up some public channels of communication.
* Be open and honest in everything you say about your software.
* Avoid being rude to anyone, even towards those who come across as rude to you.
* Present yourself as professionally as you would like to be treated.

**Step 3 - Market your project**

* Don't force your project down people's throats like a bad advertising campaign.
* Post your project on softpedia.com so that it can be picked up by other download sites.
* Provide your software as a solution to any related questions on stackoverflow.com
* Contribute to forums on groups.google.com where people may be interested in your work.

**Step 4 - Keep an eye out for bugs and questions**

* Don't forget about the maintenance side of software development.
* Log your own bugs to keep tabs on the others, and deal with security issues discretely.
* Check stackoverflow.com and your own Q&A services as often as you do your bug tracker.
* Don't be a pushover, stay true to your product "not" list.

**Step 5 - Establish a rational update policy**

* Software is never finished, only abandoned, but that's not necessarily a bad thing.
* Don't release too frequently, it can irritate your users and become extremely expensive.
* Keep your documentation up-to-date, even between releases.
* Once a project is stable, move on to the next, and update it again only when popularity drops.
